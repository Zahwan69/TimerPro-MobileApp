# TimerPro Mobile App - AI Coding Agent Instructions

## Project Overview
**TimerPro** is an Expo-based mobile timer application (iOS/Android/Web) for tracking and analyzing timing records across custom categories. Users can create categories with timer types (ASAP for fastest times, Endurance for longest times), record timings with lap tracking, and manage personal bests via persistent state.

## Architecture & Data Flow

### Core Stack
- **Frontend**: React Native + Expo Router (file-based routing)
- **State Management**: Zustand with AsyncStorage persistence
- **Styling**: NativeWind (Tailwind CSS for React Native) + React Native StyleSheet (mixed approach)
- **Type System**: TypeScript strict mode with tsconfig path alias `@/*`

### State Management Pattern (Critical)
All app state flows through `useTimerStore` in `store/useTimerStore.ts` (Zustand with AsyncStorage middleware):

**Key entities:**
- `TimerCategory`: Represents a category with `id`, `name`, `personalBestMs`, `goalMs`, `timerType` ('asap' | 'endurance'), and `createdAt`
- `TimerRecord`: A completed timing session with `id`, `categoryId`, `durationMs`, `laps[]`, `isPersonalBest`, and optional `notes`
- `TimerState`: Centralized store with categories, records, running state, and UI settings (darkMode, fontSizeMultiplier, backgroundImageUri)

**Data persistence**: 
- State is automatically persisted to AsyncStorage via Zustand's `persist` middleware
- Both categories and records survive app restarts
- Personal best calculation uses timer type logic: ASAP finds minimum duration, Endurance finds maximum

### Timer Type Logic (Domain-Critical)
Two timer modes exist - **understand this for correct PB calculations**:
- **'asap'**: Shortest time wins (lower duration = better) → min value is new PB
- **'endurance'**: Longest time wins (higher duration = better) → max value is new PB
- Helper: `isNewPersonalBest(currentTime, existingPB, timerType)` in useTimerStore applies this logic
- When adding a category or editing timer type, use `setCategoryTimerType(id, timerType)` action

## Development Workflows

### Build & Run Commands
```bash
# Development (dev client)
npm run start                 # Start Expo dev server with dev client

# Platform-specific builds
npm run android              # Run on Android device/emulator
npm run ios                  # Run on iOS simulator/device  
npm run web                  # Run on web (Metro bundler)

# EAS builds (cloud)
npm run build:dev            # Development profile
npm run build:preview        # Preview profile
npm run build:prod           # Production profile

# Code quality
npm run lint                 # ESLint + Prettier check
npm run format               # Auto-fix lint and format issues
```

### Key Configuration Files
- `app.json`: Expo app metadata, Android package (`com.zahwan.TimerPro`), EAS projectId, typed routes enabled
- `tsconfig.json`: Strict mode, baseUrl/paths alias `@/*` for absolute imports
- `tailwind.config.js`: NativeWind preset; content paths include `app/**` and `components/**`
- `metro.config.js`: Bundler config (auto-generated by Expo)

## Code Conventions & Patterns

### Component Structure
- **Functional components** with TypeScript interfaces for props (see `TimerDisplay.tsx` pattern)
- **Mixed styling approach**: 
  - NativeWind/Tailwind for simple components (`Button.tsx` uses className like `bg-indigo-500 rounded-[28px]`)
  - React Native StyleSheet for complex/computed styles (see `TimerDisplay.tsx`, `RecordVisualization.tsx`)
  - Prefer NativeWind for new simple styles, StyleSheet for dynamic/layout-heavy components
- **Icons**: Use `@expo/vector-icons` (FontAwesome5, MaterialIcons, Feather) - see tab bar in `app/(tabs)/_layout.tsx`
- **Modals & navigation**: Expo Router for page routing, React Native Modal for inline dialogs

### Store Usage Pattern
Always destructure actions from `useTimerStore()` in screen components:
```tsx
const { categories, records, isRunning, startTimer, addCategory, setDarkMode } = useTimerStore();
```
Store returns both state and actions in a single hook - do not create separate selectors unless performance is critical.

### Time Formatting
Use `formatTime(ms: number): string` from `lib/utils.ts`:
- Returns `HH:MM:SS.cs` format (centiseconds precision shown)
- Handles hours/minutes/seconds padding and omits hours if zero
- Used consistently across TimerDisplay and record visualization

### File Organization
```
app/                    # Expo Router pages (file-based routing)
  (tabs)/              # Tab layout group
    _layout.tsx        # Tab navigator setup
    index.tsx          # Timer screen (main, ~1200 LOC)
    analysis.tsx       # Records visualization screen
    settings.tsx       # Settings & profile screen
components/            # Reusable UI components
  Button.tsx           # Styled button (forwardRef pattern)
  TimerDisplay.tsx     # Timer time display
  TimerControls.tsx    # Start/pause/lap/reset buttons
  RecordVisualization.tsx  # Duration bar with lap markers
  Modal*.tsx           # Dialog components
store/                 # Zustand store
  useTimerStore.ts    # Central state (323 LOC with helpers)
  store.ts            # (if any additional store setup)
types/                # Shared TypeScript definitions
lib/                  # Utilities
```

## Integration Points & Dependencies

### External Services & Storage
- **AsyncStorage** (via `@react-native-async-storage/async-storage`): Only used through Zustand middleware for state persistence
- **Expo modules**: expo-router (routing), expo-device, expo-image-picker (for background image selection), expo-constants
- **React Navigation**: Used internally by Expo Router for tab/stack navigation

### Cross-Component Communication
- **Parent to child**: Props passing (e.g., `TimerDisplayProps` interface)
- **Global state**: All screens access `useTimerStore()` directly - no prop drilling
- **Modal/Dialog state**: Managed locally in component (e.g., `showSaveDialog` in index.tsx) with store actions triggered on confirm

### Dark Mode & UI Customization
- `isDarkMode`, `fontSizeMultiplier`, `backgroundImageUri` stored in state
- Tab bar colors/styles respond to isDarkMode (see `_layout.tsx` pattern)
- Settings screen provides UI to call `setDarkMode()`, `setFontSizeMultiplier()`, `setBackgroundImageUri()`

## Common Tasks & Examples

### Adding a Timer Category
```tsx
// In a screen component:
const { addCategory } = useTimerStore();
addCategory('Rubik\'s Cube'); // Creates category with auto-id, stores to AsyncStorage
```

### Creating a Timer Record
```tsx
// 1. Start timer (sets isRunning, currentCategory, timeElapsed)
startTimer(selectedCategory);

// 2. Record laps during timing
addLap(); // Appends to currentLaps[]

// 3. Save the completed timing as a record
saveTimer(selectedCategory.name); // Creates TimerRecord, updates PB if applicable, resets timer

// Record is automatically persisted and available in store.records
```

### Transferring Records Between Categories
```tsx
const { transferRecord } = useTimerStore();
transferRecord(recordId, newCategory); 
// Updates record.categoryId/categoryName, recalculates PBs for both old and new categories
```

### Checking Personal Best Logic
```tsx
// Store automatically handles PB comparison via isNewPersonalBest helper
// When saving a timer:
// - ASAP category: New record is PB if durationMs < existing personalBestMs
// - Endurance category: New record is PB if durationMs > existing personalBestMs
// Check record.isPersonalBest flag after creation
```

## Testing & Debugging
- **No automated tests configured** - test manually in Expo dev client
- **ESLint**: Enforces Expo config + Prettier formatting rules (react/display-name disabled)
- **Debugging**: Use Expo dev client console (`npm run start` then open in app); Chrome DevTools for web
- **State inspection**: AsyncStorage persists to device, inspect via Expo debugging tools or device storage explorer

## Important Gotchas
1. **Timer state is cleared on reset**: `currentLaps`, `timeElapsed`, `currentCategory` all reset—but records are preserved in `records[]`
2. **PB calculation is lazy**: Not recalculated retroactively—only when new records are added; editing timer type does not recompute existing records' PB flags
3. **NativeWind/Tailwind is limited**: Not all Tailwind utilities work on React Native; use StyleSheet for complex layouts or custom styling
4. **AsyncStorage is async**: Zustand handles this with middleware, but state may not be immediately available on app cold start (short delay expected)
5. **Lap times are relative**: Each lap in `currentLaps[]` is the duration of that lap segment, not cumulative—useful for RecordVisualization
